\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{polski}
\usepackage{helvet}
\usepackage{graphicx}
\usepackage{color}
\usepackage{geometry}

\usepackage[unicode]{hyperref}
\usepackage{amsmath}
\usepackage{gensymb}
\usepackage{multirow}
\usepackage{multicol}

\usepackage{lipsum} 
\usepackage{indentfirst}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
  language=python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2,
  basicstyle=\small
}

\usepackage{float}

\floatstyle{ruled}
\newfloat{kod}{htp}{lop}
\floatname{kod}{Kod}


%interrupt service routine
%gui , ui

\author{Wojciech Surówka}

\graphicspath{{fig/} {./fig/wykresy/}}
\geometry{hmargin={2cm, 2cm}, height=10.0in}

\begin{document}

% =====  STRONA TYTULOWA PRACY MAGISTERSKIEJKIEJ ====
% ostatnia modyfikacja: 2009/07/01, K. Malarz

\thispagestyle{empty}
%% ------------------------ NAGLOWEK STRONY ---------------------------------
\includegraphics[height=37.5mm]{agh_nzw_a_pl_1w_wbr}\\
\rule{30mm}{0pt}
{\large \textsf{Wydział Fizyki i Informatyki Stosowanej}}\\
\rule{\textwidth}{3pt}\\
\rule[2ex]
{\textwidth}{1pt}\\
\vspace{7ex}
\begin{center}
{\LARGE \bf \textsf{Praca magisterska}}\\
\vspace{13ex}
% --------------------------- IMIE I NAZWISKO -------------------------------
{\bf \Large \textsf{Wojciech Surówka}}\\
\vspace{3ex}
{\sf\small kierunek studiów:} {\bf\small \textsf{Fizyka Medyczna}}\\
\vspace{1.5ex}
{\sf\small specjalność:} {\bf\small \textsf{Techniki obrazowania i biometria}}\\
\vspace{10ex}
%% ------------------------ TYTUL PRACY --------------------------------------
{\bf \huge \textsf{System akwizycji danych pomiarowych dla szybkiego wielokanałowego układu scalonego o architekturze całkująco-zliczającej z detektorem promieniowania X}}\\
\vspace{14ex}
%% ------------------------ OPIEKUN PRACY ------------------------------------
{\Large Opiekun: \bf \textsf{dr inż. Piotr Wiącek}}\\
\vspace{16ex}
{\large \bf \textsf{Kraków, czerwiec 2020}}
\end{center}
%% =====  STRONA TYTUŁOWA PRACY MAGISTERSKIEJKIEJ ====

\newpage

%% =====  TYŁ STRONY TYTUŁOWEJ PRACY MAGISTERSKIEJKIEJ ====
\begin{center}
        {\bf\large\textsf{Oświadczenie studenta}}
\end{center}


{\sf Uprzedzony(-a) o odpowiedzialności karnej na podstawie art. 115 ust. 1 i 2 ustawy z dnia 4 lutego 1994 r. o prawie autorskim i prawach pokrewnych (t.j. Dz. U. z 2018 r. poz. 1191 z późn. zm.): ,,Kto przywłaszcza sobie autorstwo albo wprowadza w błąd co do autorstwa całości lub części cudzego utworu albo artystycznego wykonania, podlega grzywnie, karze ograniczenia wolności albo pozbawienia wolności do lat 3. Tej samej karze podlega, kto rozpowszechnia bez podania nazwiska lub pseudonimu twórcy cudzy utwór w wersji oryginalnej albo w postaci opracowania, artystyczne wykonanie albo publicznie zniekształca taki utwór, artystyczne wykonanie, fonogram, wideogram lub nadanie.'', a także uprzedzony(-a) o odpowiedzialności dyscyplinarnej na podstawie art. 307 ust. 1 ustawy z dnia 20 lipca 2018 r. Prawo o szkolnictwie wyższym i nauce (Dz. U. z 2018 r. poz. 1668 z późn. zm.) ,,Student podlega odpowiedzialności dyscyplinarnej za naruszenie przepisów obowiązujących w~uczelni oraz za czyn uchybiający godności studenta.'', oświadczam, że niniejszą pracę dyplomową wykonałem(-am) osobiście i samodzielnie i nie korzystałem(-am) ze źródeł innych niż wymienione w pracy.

\bigskip

Jednocześnie Uczelnia informuje, że zgodnie z art. 15a ww. ustawy o prawie autorskim i prawach pokrewnych Uczelni przysługuje pierwszeństwo w opublikowaniu pracy dyplomowej studenta. Jeżeli Uczelnia nie opublikowała pracy dyplomowej w terminie 6 miesięcy od dnia jej obrony, autor może ją opublikować, chyba że praca jest częścią utworu zbiorowego. Ponadto Uczelnia jako podmiot, o którym mowa w art. 7 ust. 1 pkt 1 ustawy z dnia 20 lipca 2018 r. --- Prawo o szkolnictwie wyższym i nauce (Dz. U. z 2018 r. poz. 1668 z późn. zm.), może korzystać bez wynagrodzenia i bez konieczności uzyskania zgody autora z utworu stworzonego przez studenta w wyniku wykonywania obowiązków związanych z odbywaniem studiów, udostępniać utwór ministrowi właściwemu do spraw szkolnictwa wyższego i~nauki oraz korzystać z utworów znajdujących się w prowadzonych przez niego bazach danych, w celu sprawdzania z wykorzystaniem systemu antyplagiatowego. Minister właściwy do spraw szkolnictwa wyższego i nauki może korzystać z prac dyplomowych znajdujących się w prowadzonych przez niego bazach danych w zakresie niezbędnym do zapewnienia prawidłowego utrzymania i rozwoju tych baz oraz współpracujących z nimi systemów informatycznych.}


\vspace{14ex}

\begin{center}
\begin{tabular}{lr}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &
................................................................. \\
~ & {\sf (czytelny podpis)}\\
\end{tabular}
\end{center}

%% =====  TYL STRONY TYTULOWEJ PRACY MAGISTERSKIEJKIEJ ====

\newpage
\rightline{Kraków, ?? czerwca 2020}
\begin{center}
{\bf Tematyka pracy magisterkiej i praktyki dyplomowej
Wojciecha Surówki,
studenta drugiego roku studiów drugiego stopnia na kierunku fizyka medyczna, specjalności Techniki obrazowania i biometria}\\
\end{center}

Temat pracy magisterskiej:
{\bf System akwizycji danych pomiarowych dla szybkiego wielokanałowego układu scalonego o architekturze całkująco-zliczającej z detektorem promieniowania X}\\

\begin{tabular}{rl}

Opiekun pracy:                  & dr inż. Piotr Wiącek\\
Recenzenci pracy:               & dr hab. inż. Owaki Śmaki\\
Miejsce praktyki dyplomowej:    & WFiIS AGH, Kraków\\
\end{tabular}

\begin{center}
{\bf Program pracy magisterskiej i praktyki dyplomowej}
\end{center}

\begin{enumerate}
\item Omówienie realizacji pracy magisterskiej z opiekunem.
\item Zebranie i opracowanie literatury dotyczącej tematu pracy.
\item Praktyka dyplomowa:
\begin{itemize}
\item zapoznanie się z ideą...,
\item uczestnictwo w eksperymentach/przygotwanie oprogramowania...,
\item dyskusja i analiza wyników...
\item sporządzenie sprawozdania z praktyki.
\end{itemize}
\item Kontynuacja obliczeń związanych z tematem pracy magisterskiej.
\item Zebranie i opracowanie wyników obliczeń.
\item Analiza wyników obliczeń numerycznych, ich omówienie i zatwierdzenie przez opiekuna.
\item Opracowanie redakcyjne pracy.
\end{enumerate}


\noindent
Termin oddania w dziekanacie: ?? czerwca 20??\\[1cm]

\begin{center}
\begin{tabular}{lcr}
.............................................................. & ~~~ &
.............................................................. \\
(podpis kierownika katedry) & & (podpis opiekuna) \\
\end{tabular}
\end{center}

\newpage

\noindent
Na kolejnych dwóch stronach proszę dołączyć kolejno recenzje pracy popełnione przez Opiekuna oraz Recenzenta (wydrukowane z systemu MISIO i podpisane przez odpowiednio Opiekuna i Recenzenta pracy). Papierową wersję pracy (zawierającą podpisane recenzje) proszę złożyć w dziekanacie celem rejestracji co najmniej na tydzień przed planowaną obroną.

\linespread{1.3}
\selectfont

\newpage
\linespread{1.3}
\selectfont
\tableofcontents
\newpage


\section{Wprowadzenie}


\subsection{Cel pracy}

Celem pracy było zaprojektowanie i skonstruowanie układu wspierającego system detekcji promieniowania X: RXHDR\_V2 \cite{master}.\\
Cele szczegółowe:
\begin{itemize}
        \item Szesnasto-kanałowy odczyt i zliczenie impulsów o częstotliwości osiągającej do 2.5$\frac{MHz}{kanal}$ z wykorzystaniem mikrokontrolera \textit{Arduiono Due}.
        \item Stworzenie oprogramowania pozwalającego na komunikację pomiędzy mikrokontrolerem a komputerem wspierajacym. 
        \item Wizualizacja i archiwizacja uzyskanych danych. 
\end{itemize}

\subsection{Wstęp teoretyczny}

W celu stworzenia programu dla tego projektu konieczne jest zrozumienie niskopoziomowego i wysokopoziomowego działania programów. Część z zagadnień koniecznych do stworzenia prototypu opisana jest poniżej. 

\subsubsection{Proces kompilacji programu na przykładzie \textit{gcc}}

Językiem rozumianym przez procesory jest kod maszynowy składający się jedynie z ciągu zer i jedynek.
Sprawia to że jest on trudny do pisania kodu i próba tworzenia w ten sposób często niesie ze sobą wiele błędów. 
Dlatego też w przeciągu lat były budowane inne języki programowania które dzięki procesowi kompilacji przetwarzają kod języka na kod maszynowy. 
Jednym z ważniejszych języków programowania stał się język \textit{c} z kompilatorem \textit{gcc - gnu c compiler}. 

Ten wysokopoziomowy język dzieli proces kompilacji na 4 podzielne części

\paragraph{Preprocesing}

Pierwszym etapem kompilacji jest preprocesing, podczas którego linie rozpoczynające się od \# są interpretowane jako komendy preprocesora.  
Za pomocą tych poleceń możemy między innymi:
\begin{itemize}
        \item Definiować zmienne - pozwala to na łatwiejszą konfigurację programu podczas fazy testów
        \item Definiować makra - ułatwiając późniejsze ponowne użycie kodu w innej części programu
        \item Warunkowo pomijać fragmenty programu - ułatwia tworzenie różnych konfiguracji programu i redukuje ilość nie używanego kodu
        \item Rozwiązywać komplikacje kompilacyjne (header guards)
\end{itemize}
Warto dodać że wszelka logika i czynności wykonane przez prepocesor nie będą wykonywane przy każdej egzekucji programu, co może pozwolić na drobne optymalizacje działania. 

\paragraph{Kompilacja}

Podczas tego etapu wcześniej przygotowany program zostaje przetłumaczony na język asemblera. 

Ten niskopoziomowy język jest już bardzo zależny od architektury procesora, i każda z  instrukcji asemblera bardzo mocno odpowiada kodzie maszynowemu danego procesora. 
Ze względu na bardzo dobrą kontrolę wykonywanych przez procesor czynności, pisanie lub edytowanie kodu w asemblerze pozwala, przy odpowiednich umiejętnościach, na ostateczną optymalizację. 
Każda z poleceń asemblera składa się z dwóch części, z mnemoniki najczęściej odpowiadający odpowiedniemu kodowi operacji procesora oraz dodatkowych danych takich jak używane rejestry lub elementy pamięci. 

\paragraph{Asemblacja}

W tym kroku przetworzony zostaje kod asemblera na język maszynowy, każda z części programu tworzy pliki z domyślnym charakterystycznym rozszerzeniem \textit{.o}.
Są to tak zwane pliki obiektowe.
Te binarne pliki już zawierające instrukcje kodu maszynowego, nie tworzą spójnej całości. Jest to zbiór elementów odpowiadający każdemu z użytych plików źródłowych.

\paragraph{Konsolidacja}
Konsolidator (eng. linker) program łączący wszystkie pliki obiektowe w jeden wykonywalny program. To właśnie na tym etapie dodaje się statyczne biblioteki oraz sprawdza obecność wcześniej zadeklarowanych zmiennych oraz upewnia się że nie pojawia się konflikt oznaczeń. Po zakończeniu tego procesu otrzymujemy gotowy program. 


\subsubsection{Czas egzekucji programu}

By wyznaczyć czas konieczny na wykonanie programu lub fragmentu programu można użyć prawa wydajności procesora:

\begin{equation}
        \label{Iron Law}
        \frac{Czas}{Program} =  \frac{Instrukcje}{Program} * \frac{Cykle}{Instrukcje} * \frac{Czas}{Cykl}
\end{equation}

Elementy tego równania są zależne od różnych elementów układu komputerowego:
\begin{itemize}
        \item $\frac{Instrukcje}{Program}$ - powiązany z językiem programowania, optymalizacji kompilatora i długości programu. 
        \item $\frac{Cykle}{Instrukcje}$ - Zależy od mikroarchitektury komputera oraz modelu programowego procesora.
        \item $\frac{Czas}{Cykl}$ -  zależny od prędkości taktowania procesora i technologi chipu. 
\end{itemize} 


W celu obliczenia ilości cykli które procesor wykonuje w przeciągu sekundy ($\frac{Czas}{Cykl}$), dla architektury w której jeden cykl zegara głównego to jeden cykl procesora, można skorzystać z równości:
\begin{equation}
        \label{Cykli w sec}
        N [1]= \frac{1}{T [Hz]}
\end{equation} 
Gdzie:\\
$N$ - ilość cykli procesora wykonywanych w przeciągu sekundy \\
$T$ - taktowanie procesora w Hz

\subsubsection{Potokowość}

W celu ograniczenia ilości cykli przypadających na jedną instrukcję używa się technologi potokowości. 
Oznacza to że pojedyńczą instrukcję dzielimy na mniejsze części i pozwalamy zasobom które odpowiadają tym częścią pracować nad następną częścią polecenia zanim całość instrukcji zostanie wykonane.

Przykładowy podział instrukcji może wyglądać następująco:
\begin{enumerate}
        \item IF - (instruction feach) - pobranie instrukcji
        \item ID - (instruction decode) -  zdekodowanie instrukcji
        \item EX - (execute) - wykonanie instrukcji - arytmetyka
        \item MEM - (memory acces) - dostęp do pamięci
        \item WB - (write back) - zapisanie wyniku
\end{enumerate}

Dzięki takiemu rozbiciu w idealnym przypadku możemy osiągnąć architekturę pozwalającą wykonywać każdą instrukcję w jednym cyklu procesora. 

\begin{table}{h}
        \centering
        \caption{Przykład pracy procesora z wykorzystaniem potokowości w idealnym przypadku.}
        \label{pipelining}
        \begin{tabular}{lcccccccc}
                Time & $t_0$&$t_1$&$t_2$&$t_3$&$t_4$&$t_5$&$t_6$&$t_7$ \\ \hline
                Instrukcja 1 & IF & ID & EX & MEM & WB &    & \\
                Instrukcja 2 &    & IF & ID & EX & MEM & WB & \\
                Instrukcja 3 &    &    & IF & ID & EX & MEM & WB \\
                Instrukcja 4 &    &    &    & IF & ID & EX & MEM & WB
        \end{tabular}
\end{table}


Taki przypadek jest wizualizowany w tabeli \ref{pipelining}. Jak widać żaden z zasobów nie jest wykorzystywany równocześnie przez dwie instrukcje.
Dodatkowo tabela \ref{pipelining} pokazuje że każda następna instrukcja jest wykonywana w kolejnym czasie $t$. 
Czas $t$ jest równy czasowi najdłuższego etapu z dodatkiem czasu wymaganego przez elektronikę zarządzającej potokowościowi \cite{arch}.
Równość ta może być zapisana wzorem:
\begin{equation}
        t = T_{e_{max}} + T_{+}
\end{equation}
Gdzie:
        $t$ - minimalny czas cyklu procesora \\
        $T_{e_{max}}$ - czas konieczny na wykonanie najdłuższego etapu \\
        $T_{+}$ - dodatkowy czas wymagany przez rejestry \\


Powyższy przykład pokazuje jedynie pięcio-etapową potokowość jednak procesory komercyjne stosują różne rozkazania tak przykładowo SMART SAM3X/A stosuje try etapową pokojowość\cite{datasheet} a mikroarchitektura Intala o nazwie Nehalem może zawierać od 20 - 24\cite{pipelining intel}.

Jednak podczas rozwiązań tego typu nie zawsze trafimy na sytuacje kiedy pojedyńczy cykl przypada dla pojedyńczej instrukcji. 
Rozwiązanie potokowości przynosi ze sobą pewne zagrożenia. Poniżej znajdują się krótkie opisy takich sytuacji. 

\begin{itemize}
        \item Dane - sytuacja gdy instrukcja wymaga informacji wytworzonej przez instrukcję ciągle realizowaną w potoku. 
        \item Zasoby - gdy polecenie wymaga użycia zasobu (RAM, PC lub ALU) który aktualnie jest używany przez inny etap potoku. 
        \item Rozwidlenia - Sytuacje gdy program zmienia swój naturalny bieg, czy to przez przerwanie systemowe czy skoki warunkowe. 
\end{itemize}

Jest wiele rozwiązań pozwalających zmniejszyć ilość wystąpień takich sytuacji lub ograniczyć straty powodowane przez takie sytuacje, jednak nadal konieczne są zastosowania chwilowego zatrzymania elementów potoku, lub w najgorszym wypadku całkowitego oczyszczenia.
Powoduje to że niektóre z instrukcji mogą wymagać większej ilości cykli niż jeden. Jednakże przy zastosowaniu takich technik jak
\textit{Out-of-order execution}, \textit{branch prediction} oraz równoległe programowanie sprawia że przewidzenie czasu koniecznego na wykonanie programu metodami analitycznymi staje się trudne . 
Z tego też powodu w tym celu stosuje się metody statystyczne oraz testowanie wzorcowe. 

\subsubsection{Programowanie wielowątkowe}

Wątek (eng. thread) jest to część programu która może być oddzielnie zarządzana przez dypozytor (eng. scheduler). 
Pozwala to na egzekucje wielu wątków równocześnie w przypadku procesorów wielowątkowych lub częste zmiany uwagi między zadaniami w procesorach jednowątkowych.
W przeciwieństwie do osobnych procesów wątki dzielą wspólną przestrzeń adresową (korzystają z tych samych danych) oraz współdzielą zasoby systemowe.

Użycie metod programowania wielowątkowego niesie ze sobą wiele zalet:
\begin{itemize}
        \item Oprogramowanie korzystające z interfejsu użytkownika może pozostać gotowe na nowe informację od użytkownika nawet podczas wykonywania trudnych obliczeń jeżeli zadanie odpowiedzialne za UI będzie osobnym wątkiem do tego wykonywającego obliczenia.
        \item Ponieważ zasoby są współdzielone między wątkami podejście wielowątkowe może być bardziej oszczędne w zasoby w porównaniu z użyciem osobnych procesów. 
        \item Program może działać szybciej i z mniejszym opóźnieniem, dzięki programowaniu z użyciem większej ilości wątków, ponieważ pozwala to na lepsze wykorzystanie popularnej architektury wielordzeniowej procesorów komercyjnych. 
        \item Każda część programu którego obliczenia mogą zostać wykonane równolegle może zyskać na szybkości przy użyciu wielowątkowego podejścia zgodnie z prawem Amdahala \cite{arch}. 
        Jednak dl przypadku obliczeń które nie pozwalają na równoległe wyliczenia, proces tworzenia wątków oraz wymaganie czekania na zwolnienie zasobów może spowodować że prędkość programu się obniży.
\end{itemize}
Jak widać użycie programowania wielowątkowego niesie ze sobą wiele korzyści,
jednak wraz z zaletami tego rozwiązania spotykamy się z pewnymi zagrożeniami i wymaganiami.

\paragraph{Synchronizacja i współdzielenie zasobów}

Tak jak było to wcześniej opisane w przeciwieństwie do rozpoczęcia nowego procesu na nowe obliczenia, programowanie wielowątkowe pozwala na kontynuowanie obliczeń bez kopiowania zasobów. 
Powoduje to jednak że wymagane są sposoby sygnalizacji między wątkami oraz sposoby ochrony zasobów przed równoczesnym dostępnie przez więcej niż jedno zadanie. 
Ta potrzeba spowodowała tworzenie powtarzalnych struktur które są implementowane w najpopularniejszych językach programowania. 
Poniżej znajduje się ich opis bez skupienia na specyfice którejkolwiek z implementacji. 
\begin{itemize}
        \item mutex/lock - obiekt który ma dwa stany zablokowany/otwarty.
        Kiedy wątek próbuje zablokować mutex/lock który już jest zablokowany powoduje to przejście wątku w stan czekania aż do chwili odblokowania przez zadanie które pierwotnie zablokowało mutex.
        Daje to możliwość wykorzystania tej struktury w celu ochrony zasobu. Przed rozpoczęciem zadania który wymaga wyłączności blokujemy mutex dając sygnał korzystania z zasobu do którego ten lock należy. 
        Po zakończeniu obliczeń zwalniamy/otwieramy mutex pozwalając pracować innym wątkom. Obiekt ten może być jedynie zwolniony przez wątek który go zablokował. 
        W ten właśnie sposób unika się równoczesnego korzystania z zasobów. 
        \item semafor (end. semaphore) - zasada działania jest podobna do mutexu jednak w przeciwieństwie do wcześniej wymienionej struktury semafor może być odblokowywany przez inne wątki niż te które zablokowały obiekt. Dodatkowo w częstej implementacji semafor może mieć więcej niż jeden stopień blokady. 
        Jest on przydatny w przypadku potrzeby synchronizacji obliczeń jeden z wątków może oznajmić że skończył swoje obliczenia i oczekuje na wynik z równoległych obliczeń, a inny wątek po zakończeniu swojej części może odblokować semafor po wykonaniu swojego zadania.   
        \item monitor - obiekt ten ma zapisaną listę aktualnie używanych zasobów i jeżeli wątek próbuje (korzystając z funkcji monitora) skorzystać z zasobu spowoduje to przejście w stan wstrzymania wątku aż do zwolnienia zasobu. 
        Monitor zapewnia funkcjonalność mutex/lock dla dowolnego zasobu, jednak korzystanie z tej funkcjonalności sprawia trudności w tworzeniu fragmentów kodu który jest krytyczny gdyż w takim przypadku konieczne byłoby skorzystanie z monitora w celu zablokowania każdego z zasobów z osobna w przeciwieństwie do mutexu który może być odpowiedzialny za wiele zasobów jednocześnie.   
\end{itemize} 

Korzystanie z funkcji synchronizujących jest konieczne w celu uniknięcia błędów występujących w wyniku korzystania z programowania wielowątkowego.

\paragraph{Race condition}

\begin{figure}[t]
        \centering
        \includegraphics[width = \textwidth]{race_condition.png}
        \caption{Schematy układów w których występuje \textit{race condition}. Po lewej \textit{(a)} przykład układu elektronicznego a po prawej \textit{{b}} schemat działania programu wielowątkowego. }
        \label{race condition}
\end{figure}

W elektronice race condition to hazard spowodowany przez czas propagacji elementów układu powodujący niezamierzane efekty. Przykład układu elektronicznego w którym występuje takowy hazard jest wizualizowany na rysunku \ref{race condition}(a). 
Race condition dzieli się na statyczny i dynamiczny. Statyczny to taki w którym obserwujemy zmianę na wyjściu w chwili gdy, dla układów o zerowej propagacji elementów spodziewalibyśmy się niezmienionego stanu.
W hazardzie dynamicznym spotykamy się z odwrotną sytuacją. 

W przypadku programowania wielowątkowego tego typu hazard nie jest powodowany przez czas propagacji elementów lecz przez nieznany czas i kolejność wykonywania operacji przez równolegle pracujące wątki. Przykład schematu programu dla takiego przypadku znajduje się na rysunku \ref{race condition}(b). Schemat przedstawia prostą bazę danych i dwa wątki mające za zadanie podniesienie wartości zmiennej \textit{N} o jeden.
Prosty proces zmiany zmiennej składa się z trzech oddzielnych części, pobranie wartości zmiennej, zwiększenie wartości oraz ponowne zapisanie zmiennej w pamięci. 
Dla podanego przykładu w typowym przebiegu gdy obydwa wątki zwiększą wartość zmiennej o 1 spodziewany jest wynik $N = n+2$, jednak rzadkim przypadku może zaistnieć sytuacja że drugi wątek pobierze wartość N do obliczeń przed zapisaniem wyniku z pierwszej operacji. Spowoduje to trudny do odnalezienia i odtworzenia błąd sprawiający że zignorowane zostają obliczenia wątku który pierwszy pobrał wartość, zatem końcowy wynik będzie równy $N = n+1$.
Jest to jeden z powodów dlaczego zabezpiecza się zasoby za pomocą muteksów lub semaforów. 

Mimo sposobów na unikanie takich sytuacji programowanie wielowątkowe wymaga dużej staranności a potencjalne błędy mogą pozostawać ukryte nawet latami. To też jest powód dla którego nie należy stosować takich rozwiązań jeżeli mogą zostać pominięte\cite{multi thread problem}.
\paragraph{Zakleszczenie}

Zakleszczenie (ang. deadlock) to sytuacja gdy dwie operacje czekają na siebie wzajemnie więc żadna z nich nie może się zakończyć. 
Zakleszczenie może występować w procesach, wątkach jak i również w świecie fizycznym przykładowo w ruchu drogowym podczas blokady rąda w korku drogowym.  
Prostym przykładem takiej sytuacji jest chwila gdy dwa procesy w celu przeprowadzenia potrzebują dwóch muteksów i w chwili gdy każdy z nich zablokuje jeden z nich przechodzą w stan wstrzymania oczekując na zwolnienie tego trzymanego przez konkurujący proces. 
Jest to jednak trudna sytuacja do przewidzenia, gdyż w bardziej rozbudowanych sytuacjach kiedykolwiek występuje graf cykliczny zapotrzebowania zasobów, deadlock może zaistnieć. 

W celu uniknięcia takiej sytuacji można wprowadzić pewne środki zapobiegawcze\\cite{coffman}:
\begin{itemize}
        \item Proces/wątek blokuje zasoby dopiero kiedy wszystkie są dostępne. Jest to mało optymalne rozwiązanie i może spowodować że operacja nigdy nie zostanie przeprowadzona
        \item Ustalenie mechanizmu wywłaszczania zasobów oraz hierarchii dostępu. 
        \item Przed przejściem w stan oczekiwania proces może zwolnić wszystkie przetrzymywane zasoby. 
        \item Usunięcie wymagania wyłączności. Jeżeli zasób może być używany przez wiele wątków/procesów jednocześnie to nie należy go blokować.  
        \item Projektowanie programu tak by proces/wątek wymagał jednocześnie dostępu jedynie do jednego zasobu na raz. 
\end{itemize} 

Jest to kolejny powód dla którego należy bardzo rozsądnie podchodzić do projektowania programu przy decyzji programowania wielowątkowego oraz nie nadużywać w sytuacjach gdy jest to niekonieczne. 

\subsubsection{Otwarte formaty danych}

Pliki o otwartych formatach danych to takie pliki tekstowe których metadane oraz semantyka jest ogólnie dostępna.
Oznacza to że nie tylko są to formaty które są często implementowane w wielu programach, ale również umożliwiają ręczną manipulację danymi przez użytkownika.  
Poniżej znajdują się krótkie opisy najpopularniejszych formatów.

\paragraph{CSV}
CSV (ang. comma seperated values, wartości dzielone przecinkami) jest to prosty format plików w którym zgodnie z nazwą każda z wartości jest oddzielana przecinkiem od kolejnej. Wartości dzielą się na rekodry oddzielane znakami końca linii CRLF oraz wartości oddzielane przecinkami. Zamiast przecinków mogą być używane znaki specjalne jak średniki lub tabulatury chociaż jest to niezalecane. Jeżeli plik z danymi zawiera tablicę to ilość wartości powinna być jednakowa w każdym z rekordów. 

\paragraph{XML}

XML (eng. Extensible Markup Language) jest to uniwersalny język znaków służący do przenoszenia danych. Jego skupieniem była łatwość w pisaniu programów interpretujących ten standard.
Jest to język na podstawie którego stworzono wiele ważnych pochodnych formatów takich Microsoft Office XML formats, Trusted Data Format i HTML5.

Poniżej znajduje się prosty przykład takowego dokumentu:
\begin{kod}
        \lstinputlisting[language=XML]{code_source/XML.xml}
        \caption{Schematyczny przykład zawartości pliku napisanego w języku XML}
        \label{XML code}
\end{kod}

Dokument XML składa się z elementów, atrybutów oraz tagów. 
Tagi znajdują się między symbolami < > oraz każdy z nich wymaga zamknięcia przez tag o tej samej nazwie rozpoczynając się od symbolu \\.
Atrybuty to pary wartość klucz znajdujące się między symbolami < > gdzie wartość zawsze musi być zawarta między znakami ".
Wartości to tekst lub kolejne elementy znajdujące się między tagami. 
Pierwsza linia to opcjonalny prolog zawierający informację o wersji XML oraz typie kodowania.  
Dokument XML musi zawierać element początkowy. W przykładowym kodzie \ref{XML code} jest to tag <root>.



\paragraph{JSON -  Java script object notation}

Mimo że nie jest standardem otwartych plików danych, lecz formą języka JavaScript to spełnia warunki czytelności przez człowieka jak i maszynę. 
Forma obiektu w tym języku stała się w przeciągu lat popularnym sposobem na przekazywanie danych między aplikacjami. Stało się tak ze względu na prostotę sematyki oraz uniwersalność. 

Każdy obiekt JSON zaczyna się symbolem \{ i kończy \} każda z wartości składa się z pary atrybut wartość przedzielona dwukropkiem, a każda z kolejnych par oddziela się przecinkiem. Typami wartości są:
\begin{itemize}
        \item liczba, 
        \item tekstowy typ danych (eng. string),
        \item logiczny typ danych,
        \item tablica - zaczyna się od [ kończy na ],
        \item obiekt,
        \item wartość pusta - null. 
\end{itemize}

Format ten wspierany jest przez wiele języków między innymi C, C++, C\#, Java, JavaScript, Perl, Python\cite{json}.

%przerwania systemowe
%mulithreading programing deadlock's
%typy plików z danymi
%Alu
\section{Projekt}

Zgodnie z dokumentacją RXHDR\_V2 \cite{master} na szesnastu wyjściach cyfrowych uzyskiwany jest sygnał o logice 0 do 1.8$V$ o czasie trwania między 50$ns$ a 200$ns$ i częstotliwości osiągającej nawet do 2.5 $MHz$.
Sygnał ten na potrzeby rozwiązań softwarowych jest modyfikowany przez translator poziomów do poziomów logicznych 0 - 3.6$V$ i zostaje wybierana ósemka z szesnastu kanałów przez multiplexer.    
Tak otrzymane sygnały należy zliczyć na płytce Arduino Due w ściśle określonym czasie oraz przekazać dane do dalszej obróbki bodź wizualizacji na zewnętrznym komputerze.

W poniższych rozdziałach opisane są proponowane sposoby wykonania tego zadania. 

Cały proces kompilacji kodu C++ do kodu Asemblera został wykonany na kompilatorze ARM gcc 4.6.4 (linux). 

\subsection{Rozwiązanie softwarowe na platformie Arduino}
Bezpośrednie zliczenie sygnałów z wykorzystaniem przerwań sprzętowych w frameworku Arduino. Projekt ten zakłada użycie przerwań sprzętowych na wyjściach cyfrowych. 
Po ograniczeniu sygnałów do ośmiu wyjść przez multiplexer każde ze zboczy powoduje wywołanie krótkiej dedykowanej funkcji zwiększającej wartość licznika o jeden. 

Poniżej znajduje się fragment prototypowego kodu użytego do badań. Na potrzeby badania zostaje uwzględniony tylko pojedyńczy kanał.

\begin{kod}
        \lstinputlisting[language=C++, firstline=95, lastline=117]{code_source/arduino/monocanal_rst.cpp}
        \caption{Fragment kodu użytego do testowania rozwiązania z przerwaniami systemowymi.}
        \label{code_ard_IRS}
\end{kod}


Używana płytka rozwojowa Arduino Due, używa microkontrolera AT91SAM3X8E w architekturze 32 bitowej i taktowaniu głównego procesora równemu 84 $MHz$.

Pomimo krótkiej operacji wewnątrz IRS - \textit{add} (tabela \ref{decompile add}) proces wejścia do rutyny przerwania i wyjścia zabiera nieporównywalnie więcej cykli procesora, co powoduje że cały proces wywołania przerwania jest kosztowny w czasie. 
Ilość cykli procesora koniecznych do wywołania funkcji przerwania używając nieoptymalizowanego kodu Arduino może wymagać nawet do 355 cykli procesora \cite{ard_opt_git}, dodatkowo powrót do głównego wątku programu może wymagać kolejne 128 cykli \cite{ard_opt_git}.

\begin{table}{h}
        \begin{center}
        \caption{Estymacja ilości cyklów procesora koniecznych do wykonania instrukcji umieszczonych w funkcji \textit{add} }
        \label{decompile add}
        \begin{tabular}{c|c|c}
                kod C++ & pseudo kod Asemblera & Ilość cylki procesora \cite{cycles} \\ \hline
                val++ & LDR & 1-2 \\
                        & ADD & 1 \\
                        & STR & 1-2 \\ 
                        \hline \hline
                        &   &  3-5 
        \end{tabular}
        \end{center}
\end{table}

Pojedyńczy cykl procesora zgodnie z wzorem \ref{Cykli w sec} dla układu Arduino Due trwa ~$ 11.9 ns $. 
Oznacza to że wykonanie instrukcji \textit{val ++} zgodnie z najgorszą estymacja (tabela \ref{decompile add}) trwa ~ $59.52 ns$. 
Jednak po dodaniu czasu koniecznego na wywołanie i powrót z IRS otrzymywany jest czas $ (355 + 128 + 5) * 11.9 ns =  5.8072 \mu s $. 

Podczas wywołania przerwania o tym samym priorytecie co priorytet tego właśnie wykonywanego, sygnał wywołujący zostanie zapamiętany i ewaluowany zaraz po wyjściu z właśnie wykonywanego IRS  \cite{datasheet}. 
Oznacza to że w przypadku generowania sygnałów o większej częstotliwości niż jest możliwa ich ewaluacja, doprowadzamy do sytuacji kiedy nigdy nie wrócimy do normalnego przebiegu programu. 

Zgodnie z wymaganiami zadania uzyskiwane sygnały wymagające zliczenia mogą przychodzić z częstotliwością $2.5MHz$ co oznacza kolejny sygnał co $0.4\mu s$.
Taka częstotliwość oznacza że już dla pojedyńczego kanału takie rozwiązanie jest niewystarczające. 

\subsection{Rozwiązanie softwarowe w standardzie CMSIS}
%Bezpośrednie zliczenie sygnałów z układu RXHDR\_V2 z wykorzystaniem przerwań sprzętowych w frameworku architektury ARM32 dla procesora AT91SAM3X8E, znajdującego się na płytce Arduino Due.
Główną filozofią platformy Arduiono jest możliwość przenoszenia kodu między różnymi urządzeniami należącymi do dużej rodziny Arduino oraz łatwość programowania.
W celu osiągnięcia tych dwóch celów często poświęcana jest szybkość działania. 

Dodatkowo platforma Arduino implementuje funkcję których działanie może wpływać na pracę mikrokontrolera nawet bez ich wywoływania. 
Przykładowo na potrzeby działania funkcji \textit{milis()} konieczna jest specyficzna konfiguracja głównego zegara i cykliczne wywoływanie przerwań w celu implementacji licznika.  


CMSIS to biblioteka udostępniająca warstwę abstrakcji dla mikrokontrolerów używających procesorów grupy ARM Cortex. 
Pozwala ona na niskopoziomowe programowanie na procesory tego typu ze skupieniem na szybkość działania.

Zgodnie z notą producenta \cite{interupt latency} w najbardziej optymalnej sytuacji dla procesora \textit{Cortex-M3} wejście do funkcji przerwania sprzętowego to 12 cykli i wyjście równe 10 cyklom. 
Przy tak optymistycznej estymacji możliwe byłoby osiągnięcie częstotliwości zliczeń nawet do $\frac{1}{11.9ns*27} = ~ 3.11 Mhz$, jednak ponieważ zliczenia z różnych kanałów nie mogą być ewaluowane równolegle wynik ten nadal jest niewystarczający. 

Dodatkowo bez dostępu do debugera rozwiązywanie problemów pojawiających się podczas programowania w tym podejściu okazały się niewarte włożonej procy. 

Z tych dwóch powodów rozwiązanie to zostało porzucone i nie wykonano prób w tym podejściu. 


\subsection{Rozwiązanie z użyciem dodatkowego układu elektronicznego.}

Wykorzystanie rozwiązania z dodatkowym układem elektroniki przy wykorzystaniu frameworku Arduino

\subsubsection{Układ liczników zewnętrznych}
\subsubsection{Oprogramowanie microkontrolera}
\subsection{Program kontroli, wizualizacji oraz archiwizacji danych}

\section{Wyniki badań}

\section{Podsumowanie}

\newpage
\begin{thebibliography}{99}

        \bibitem{arch}
        John L. Hennessy, David A. Patterson 
        \textit{Computer Architecture: A Quantitative Approach  5th Edition }
        The Morgan Kaufmann Series in Computer Architecture and Design

        \bibitem{gcc}
        988-2019 Free Software Foundation
        \textit{Using GCC: The GNU Compiler Collection Reference Manual, v. 3.3}
        GNU press

        \bibitem{multi thread problem}
        Edward A. Lee
        \textit{The Problem with Threads}
        Electrical Engineering and Computer Sciences
        University of California at Berkeley
        Technical Report No. UCB/EECS-2006-1
        \url{http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.html}
        January 10, 2006

        \bibitem{coffman}
        Coffman conditions
        \url{http://personal.kent.edu/~rmuhamma/OpSystems/Myos/deadlockCondition.htm}
        Odwiedzono: maj 2020

        \bibitem{json}
        Introducing JSON
        \url{https://www.json.org/json-en.html}
        Odwiedzono: maj 2020

        \bibitem{multithreding microsoft}
        Microsoft 2020
        \textit{Managed threading best practices}
        \url{https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices}
        Odwiedzono: Maj 2020
        
        \bibitem{master}
	W. Dąbrowski, T. Fiutowski, P. Wiącek 
	\textit{\detokenize{RXHDR_v2} - SPECIFICATION},
	AGH University of Science and Technology
        Faculty of Physics and Applied Computer Science 

        \bibitem{pipelining intel}
        bit-tech.net
        \url{https://www.bit-tech.net/reviews/tech/cpus/intel-core-i7-nehalem-architecture-dive/5/}
        Odwiedzono:
        Kwiecień 2020

        \bibitem{pyserial}
	Chris Liechti,	
	\url{https://pyserial.readthedocs.io/en/latest/pyserial_api.html}
        Odwiedzono: Wrzesień 2, 2018
        
        \bibitem{arduino}
	 Arduino 2018,
	 \url{https://www.arduino.cc/reference/en/}
        Odwiedzono: Wrzesień 13, 2018	 
        
        \bibitem{cycles}
        1995-2020 Arm Limited (or its affiliates)
        \url{https://developer.arm.com/docs/ddi0337/latest/programmers-model/instruction-set-summary/cortex-m3-instructions#ftn.CCHCDDFI}
        Odwiedzono: Kwiecień 2020

        \bibitem{ard_opt_git}
        \url{https://github.com/manitou48/DUEZoo}
        Odwiedzono: Kwiecień 2020

        \bibitem{datasheet}
        Atmel Corporation
        \textit{Atmel | SMART ARM-based MC  / Datasheet}
        \detokenize{ Atmel-11057C-ATARM-SAM3X-SAM3A-Datasheet_23-Mar-15. }

        \bibitem{interupt latency}
        Atmel Corporation
        \url{http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka16366.html}
        Odwiedzono Kwiecień 2020

\end{thebibliography}


\end{document}

